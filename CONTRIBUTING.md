
I have big plans for this terminal emulator, but probably will not have a lot of time to work on it.  I want to lay out my ideas here so that potential contributors can understand where I intend the project to go, and so that I don't forget it myself.  Feedback on these plans are welcome and encouraged - I would like to know other people's thoughts.  I don't want to make a terminal emulator to just do what is already done, and I don't do everything in the terminal because I'm old-fashioned or some sort of luddite.  I use terminals because it can be a much more powerful and efficient way of interacting with a computer than pointing around with the rat and clicking on the few options that can be visually displayed.  I want to move away from a lot of the historical baggage of terminal emulators and their use that have grown since the 60s or 70s.  So feel free to contribute ideas or code if you are a like-minded terminal lover.

By the way, if you contribute code, it's currently somewhat a mess -- the rationale for actually starting this was to learn racket, and a bunch of the code is really gross as I threw it together as fast as I could while learning how to make things work.

Plans
=====

* I want to use the core library to make multiple frontends -- I want to have it back an xterm, a GUI terminal widget (canvas%, so far, that is used in the xterm, but can also be embedded in other gui programs if desired), a tmux/screen style console terminal emulator/multiplexer, and any other frontend (I imagine a weekend project of a framebuffer terminal, some day, or at some point being able to run racket on Android and replacing the no-longer-developed-or-accepting-new-features terminal for Android...).  My plan is for the terminal object to keep track of all the state and the frontend will just draw it out and send input to it.
* I want to extend the capabilities of terminal emulators past what is currently done -- I want to add graphical elements in the forms of:
    - GUI cells (IE bitmaps can be drawn in cells that would normally hold characters)
    - overlays (IE drawn on an otherwise transparent layer above the characters.
* This would allow for things such as:
    - drracket style drawing lines to show usages of a symbol
    - emacs, powerline, etc to draw weird pictures/glyphs without requiring special modified fonts
    - some people want to add gui symbols, controls, etc to console programs (I'm less on board here, because I hate anything that will end up requiring mouse interaction, but any well written program should be able to avoid that).
    - various other things I haven't even thought of, I'm sure
* I want to get away from parsing crazy escape codes, and I want to get away from terminal capabilities being inferred by some third party database.  The days are long gone when people connected a dumb hardware terminal to a serial port.  Now every terminal is a smart terminal, so the terminal should be able to talk with the client program and simply tell it its capabilities.  To do these, I want to add an embedded interpreter.  There are codes that already accept a field of arbitrary text -- ESC ] <number> ; <text> <string-terminator>.  I want to add one that will be for evaluating... probably scheme, with added "terminal primitives" for all needed terminal operations.  I figure R5RS or some such will be adoptable by other terminal emulators if the idea ever became popular, so code written to run on a rackterm can also work on other terminals that decide to implement it, via one of the myriad of embeddable schemes.  This will have to be combined with a canonical format of sending any necessary responses back to the client -- it can just expect to receive a certain similar escape sequence soon after sending a request that needs a reply.  The rationale behind having replies and such is so that a client can ask about capabilities of the interpreter (IE are you r5rs, r6rs...?  Do you support italics?  Do you support slanting the opposite way of italics? etc).
* I want it to be very configurable (probably in racket code itself) - both the tmux/screen version and a future multiplexing xterm version will need various commands to split the view and open another terminal, switch over to another background window of terminals, do window management tasks, etc.  I want the key configuration to have first class support for modality (a la vim -- if it's not there someone always wants to hack it in anyhow, eg. [tmuxmodality.py](https://github.com/mtl/tmux-modality)), and chains of keys (eg C-c C-n, like emacs has for so much stuff).  The default config need not use either of those, but I'm quite sure I will use both.
* I want there to be good configuration for mapping input characters to other things -- arrow keys, other named keys, function keys, etc need these weird mappings.  You can also add mappings so you can use super and hyper modifiers in the terminal (like control and alt).  I would also like to be able to map C-m and C-i, which are the same as return and tab, respectively.  Then there is always the debate over whether the backspace key should send BS or DEL...
* I would like the bulk of configuration to be able to be shared by the various frontends to rackterm, but individual modifications to be made to each.  Also, the configuration should be able to source more than one file.  A common pattern I use is to keep my main configuration for programs in my dotfiles, but source a local configuration file if it exists to add any extra configuration I need on a specific computer.  Common differences may include font sizes, for example.
* Since I want configuration to be in full racket, but many people like simple, weak configuration, perhaps it could load configuration in multiple formats, or there could be a #lang rackterm-config which would make it easy.  The configuration could be loaded with some dynamic-require or perhaps xmonad-style by wrapping the original code with the configuration to make a new executable.
* And, of course, I want all the expected terminal features that I don't have yet -- scrollback, mouse support, copy/paste with display server, etc.

Other thoughts
--------------

I also would like to make a better shell -- I want better, more useful, and more helpful interactive use, primarily.  Also it would be nice if it scaled up to useful programming better than the bourne derived shells.  This would be a huge project which I will likely never actually get around to, but thinking of some features I would like in the shell was part of the motivation to start working on a new terminal emulator with more features.  Some people are trying to put a bunch of intelligence into terminal emulators to know about the commands used in them and parse their output to add extra functionality.  I think that won't scale, and is really a dead end.  I think that "intelligence" needs to go into the programs themselves (such as a better, more helpful shell), but the terminal emulator needs more ways to display things -- more styles of displaying text, the ability to display some pictures, etc.  My only hope is that people make all of these things in a way that doesn't require mousing -- some of the key strengths of console computing are being able to do everything from the keyboard and having no dialog windows.
